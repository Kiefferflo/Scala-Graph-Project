[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/undirected/SimpleGraphDefaultImpl.scala","languageId":"scala","version":1,"text":"package undirected\n\n/** Default implementation for [[SimpleGraph]]\n  * @param vertices vertex set\n  * @param edges edges set\n  * @tparam V type for vertices\n  */\ncase class SimpleGraphDefaultImpl[V](vertices : Set[V], edges : Set[Edge[V]]) extends SimpleGraph[V] {\n    /** @inheritdoc */\n    def neighborsOf(v: V): Option[Set[V]] =\n      if (!(vertices contains v)) None else Some(vertices filter { edges contains Edge(v, _) })\n\n    /** @inheritdoc */\n    def + (v: V): SimpleGraphDefaultImpl[V] =\n      SimpleGraphDefaultImpl(vertices + v, edges)\n\n    /** @inheritdoc */\n    def - (v: V): SimpleGraphDefaultImpl[V] =\n      SimpleGraphDefaultImpl(vertices - v, edges filterNot { e => Set(e._1, e._2) contains v })\n\n    /** @inheritdoc */\n    def +| (e: Edge[V]): SimpleGraphDefaultImpl[V] =\n      SimpleGraphDefaultImpl(vertices ++ Set(e._1, e._2), edges + e)\n\n    /** @inheritdoc */\n    def -| (e: Edge[V]): SimpleGraphDefaultImpl[V] =\n      SimpleGraphDefaultImpl(vertices, edges - e)\n\n    /** @inheritdoc */\n    def withoutEdge: SimpleGraphDefaultImpl[V] =\n      SimpleGraphDefaultImpl(vertices, Set.empty[Edge[V]])\n\n    /** @inheritdoc */\n    def withAllEdges: SimpleGraphDefaultImpl[V] =\n      SimpleGraphDefaultImpl(vertices, for (v1 <- vertices ; v2 <- vertices) yield Edge(v1, v2))\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (/home/cytech/scala-graph-project/target/scala-2.13/zinc/inc_compile_2.13.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 1 s, completed Mar 16, 2022, 3:30:55 PM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mForcing garbage collection...[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/undirected/Edge.scala","languageId":"scala","version":1,"text":"package undirected\n\n/** Edge of an undirected graph as an unordered pair\n  *\n  * Source : [[https://gist.github.com/dmyersturnbull/2295d91ef503bb3eec6d]]\n  * @param _1 one end of edge\n  * @param _2 the other end of edge\n  * @tparam V type of vertex\n  */\ncase class Edge[V](_1 : V, _2 : V) {\n    /** Get the other end of the edge\n      * @param v one end\n      * @return [[None]] if `v` is not an actual end, the other end otherwise\n      */\n    def adjacentTo(v : V) : Option[V] =\n      if (v == _1) Some(_2) else if (v == _2) Some(_1) else None\n\n    /** Edge representation in DOT language */\n    lazy val toDOTString : String = s\"${_1} -- ${_2}\"\n\n    /** @inheritdoc */\n    override lazy val toString : String = toDOTString\n\n    /* [equals] is redefined so Edge(a, b) == Edge(b, a) */\n    /** @inheritdoc */\n    override def equals(o : Any) : Boolean = o match {\n        case that : Edge[V] => that._1 == _1 && that._2 == _2 || that._1 == _2 && that._2 == _1\n        case _              => false\n      }\n\n    /* [hashCode] is redefined so Edge(a, b).hashCode == Edge(b, a).hashCode */\n    /** @inheritdoc */\n    override def hashCode : Int = _1.hashCode * _2.hashCode\n  }\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/undirected/SimpleGraph.scala","languageId":"scala","version":1,"text":"package undirected\n\nimport scala.annotation.tailrec\n\n/** Trait for an undirected and ''simple'' graph, that is without loop nor parallel edges\n  * @tparam V type for vertices\n  */\ntrait SimpleGraph[V] {\n    /* QUERY METHODS */\n\n    /** The set of all vertices of the graph */\n    val vertices : Set[V]\n\n    /** The set of all    edges of the graph */\n    val edges : Set[Edge[V]]\n\n    /** The set of all vertices adjacent to input vertex\n      * @param v vertex\n      * @return [[None]] if `v` is not an actual vertex, the set of all neighbors of `v` otherwise (may be empty)\n      */\n    def neighborsOf(v : V) : Option[Set[V]]\n\n    /** The number of adjacent vertices to input vertex\n      * @param v vertex\n      * @return [[None]] if `v` is not an actual vertex, the degree of `v` otherwise\n      */\n    def degreeOf(v : V) : Option[Int] = neighborsOf(v) map { _.size }\n\n    /** Checks if there exists a path between two vertices\n      * @param v1 one end of path to search\n      * @param v2 other end of path to search\n      * @return `true` if `v1` and `v2` are equal or if a path exists between `v1` and `v2`, `false` otherwise\n      */\n    def hasPath(v1 : V, v2 : V) : Boolean = ???\n\n    /** Checks if graph is connected */\n    lazy val isConnected : Boolean = ???\n\n    /** Checks if graph is acyclic */\n    lazy val isAcyclic : Boolean = ???\n\n    /** Checks if graph is a tree */\n    lazy val isTree : Boolean = isConnected && isAcyclic\n\n    /* VERTEX OPERATIONS */\n\n    /** Add vertex to graph\n      * @param v new vertex\n      * @return the graph with new vertex `v`\n      *         if `v` is an actual vertex of graph, return input graph\n      */\n    def + (v : V) : SimpleGraph[V]\n\n    /** Remove vertex from graph\n      * @param v new vertex\n      * @return the graph without vertex `v`\n      *         if `v` is not an actual vertex of graph, return input graph\n      */\n    def - (v : V) : SimpleGraph[V]\n\n    /* EDGE OPERATIONS */\n\n    /** Add edge to graph (also add edge ends as new vertices if necessary)\n      * @param e new edge\n      * @return the graph with new edge `e`\n      *         if `e` is an actual edge of graph, return input graph\n      */\n    def +| (e : Edge[V]) : SimpleGraph[V]\n\n    /** Remove edge from graph (does NOT remove ends)\n      * @param e new edge\n      * @return the graph without edge `e`\n      *         if `e` is not an actual edge of graph, return input graph\n      */\n    def -| (e : Edge[V]) : SimpleGraph[V]\n\n    /** Remove all edges from graph but keep same vertices\n      * @return graph with same vertices without any edge\n      */\n    def withoutEdge : SimpleGraph[V]\n\n    /** Add all possible edge with same vertices\n      * @return graph with same vertices and all possible edges\n      */\n    def withAllEdges : SimpleGraph[V]\n\n    /* VALUATED GRAPH METHODS */\n\n    /** Total value of the graph\n      * @param valuation valuation used\n      * @return total value of the graph, i.e. sum of values of all edges\n      */\n    def value(valuation : Map[Edge[V], Double]) : Double = (edges map { valuation(_) }).sum\n\n    /** Minimum spanning tree\n      * @param valuation valuation used\n      * @return a spanning tree whose value is minimal\n      */\n    def minimumSpanningTree(valuation : Map[Edge[V], Double]) : SimpleGraph[V] = ???\n\n    /* COLORING METHODS */\n\n    /** Sequence of vertices sorted by decreasing degree */\n    lazy val sortedVertices : Seq[V] = ???\n\n    /** Proper coloring using greedy algorithm (a.k.a WELSH-POWELL) */\n    lazy val greedyColoring : Map[V, Int] = ???\n\n    /** Proper coloring using DSATUR algorithm */\n    lazy val coloringDSATUR : Map[V, Int] = ???\n\n    /* toString-LIKE METHODS */\n\n    /** @inheritdoc */\n    override lazy val toString : String = s\"({${vertices mkString \", \"}}, {${edges mkString \", \"}})\"\n\n    /** Graph representation in DOT language */\n    lazy val toDOTString : String = {\n        \"strict graph {\\n\" +\n        \"    // Edges\\n\" +\n        (edges foldLeft \"    \") { _ + _.toDOTString + \"\\n    \" } + \"\\n\" +\n        \"    // Vertices\\n\" +\n        vertices.mkString(\"    \", \"\\n    \", \"\\n\") +\n        \"  }\\n\"\n      }\n\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/undirected/SimpleGraphMatrixImpl.scala","languageId":"scala","version":1,"text":"package undirected\n\n/** Implementation of [[SimpleGraph]] using adjacency matrix\n  * @param vs sequence of vertices in the order they are used in adjacency matrix\n  * @param adjacency adjacency matrix\n  * @tparam V type for vertices\n  */\ncase class SimpleGraphMatrixImpl[V](vs : Seq[V], adjacency : IndexedSeq[IndexedSeq[Int]]) extends SimpleGraph[V] {\n\n    /** @inheritdoc */\n    lazy val vertices : Set[V] = ???\n\n    /** @inheritdoc */\n    lazy val edges : Set[Edge[V]] = ???\n\n    /** @inheritdoc */\n    def neighborsOf(v : V) : Option[Set[V]] = ???\n\n    /** @inheritdoc */\n    def + (v : V) : SimpleGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def - (v : V) : SimpleGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def +| (e : Edge[V]) : SimpleGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def -| (e : Edge[V]) : SimpleGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def withoutEdge : SimpleGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def withAllEdges : SimpleGraphMatrixImpl[V] = ???\n  }\n\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/undirected/SimpleGraphNeighborsImpl.scala","languageId":"scala","version":1,"text":"package undirected\n\n/** Implementation of [[SimpleGraph]] using list of neighbors for each vertex\n  * @param neighbors associative map providing set of neighbors for each vertex\n  *                  Key must be defined for any vertex in graph : should an actual vertex have no neighbor, value is defined and is an empty set\n  * @tparam V type for vertices\n  */\ncase class SimpleGraphNeighborsImpl[V](neighbors : Map[V, Set[V]]) extends SimpleGraph[V] {\n\n    /** @inheritdoc */\n    val vertices : Set[V] = ???\n\n    /** @inheritdoc */\n    val edges : Set[Edge[V]] = ???\n\n    /** @inheritdoc */\n    def neighborsOf(v: V) : Option[Set[V]] = ???\n\n    /** @inheritdoc */\n    def + (v : V) : SimpleGraphNeighborsImpl[V] = ???\n\n    /** @inheritdoc */\n    def - (v : V) : SimpleGraphNeighborsImpl[V] = ???\n\n    /** @inheritdoc */\n    def +| (e: Edge[V]) : SimpleGraphNeighborsImpl[V] = ???\n\n    /** @inheritdoc */\n    def -| (e: Edge[V]) : SimpleGraphNeighborsImpl[V] = ???\n\n    /** @inheritdoc */\n    def withoutEdge : SimpleGraphNeighborsImpl[V] = ???\n\n    /** @inheritdoc */\n    def withAllEdges : SimpleGraphNeighborsImpl[V] = ???\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/directed/StrictGraphDefaultImpl.scala","languageId":"scala","version":1,"text":"package directed\n\n/** Default implementation for [[StrictGraph]]\n  * @param vertices vertex set\n  * @param arcs arcs set\n  * @tparam V type for vertices\n  */\ncase class StrictGraphDefaultImpl[V](vertices : Set[V], arcs : Set[Arc[V]]) extends StrictGraph[V] {\n\n    /** @inheritdoc */\n    def successorsOf(v: V): Option[Set[V]] =\n      if (!(vertices contains v)) None else Some(vertices filter { arcs contains Arc(v, _) })\n\n    /** @inheritdoc */\n    def + (v: V): StrictGraphDefaultImpl[V] =\n      StrictGraphDefaultImpl(vertices + v, arcs)\n\n    /** @inheritdoc */\n    def - (v: V): StrictGraphDefaultImpl[V] =\n      StrictGraphDefaultImpl(vertices - v, arcs filterNot { e => Set(e._1, e._2) contains v })\n\n    /** @inheritdoc */\n    def +| (e: Arc[V]): StrictGraphDefaultImpl[V] =\n      StrictGraphDefaultImpl(vertices ++ Set(e._1, e._2), arcs + e)\n\n    /** @inheritdoc */\n    def -| (e: Arc[V]): StrictGraphDefaultImpl[V] =\n      StrictGraphDefaultImpl(vertices, arcs - e)\n\n    /** @inheritdoc */\n    def withoutArc: StrictGraphDefaultImpl[V] =\n      StrictGraphDefaultImpl(vertices, Set.empty[Arc[V]])\n\n    /** @inheritdoc */\n    def withAllArcs: StrictGraphDefaultImpl[V] =\n      StrictGraphDefaultImpl(vertices, for (v1 <- vertices ; v2 <- vertices) yield Arc(v1, v2))\n  }\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/directed/StrictGraph.scala","languageId":"scala","version":1,"text":"package directed\n\nimport scala.annotation.tailrec\n\n/** Trait for a directed ''and strict'' graph, i.e. without loop nor parallel arcs */\ntrait StrictGraph[V] {\n    /* QUERY METHODS */\n\n    /** The set of all vertices of the graph */\n    val vertices : Set[V]\n\n    /** The set of all     arcs of the graph */\n    val arcs : Set[Arc[V]]\n\n    /** The set of all vertices with arcs incoming from input vertex\n      * @param v vertex\n      * @return [[None]] if `v` is not an actual vertex, the set of all successors of `v` otherwise\n      */\n    def successorsOf(v : V) : Option[Set[V]]\n\n    /** The number of incoming arcs to input vertex\n      * @param v vertex\n      * @return [[None]] if `v` is not an actual vertex, the inner degree of `v` otherwise\n      */\n    def inDegreeOf(v : V) : Option[Int] = ???\n\n    /** The number of outcoming arcs to input vertex\n      * @param v vertex\n      * @return [[None]] if `v` is not an actual vertex, the outer degree of `v` otherwise\n      */\n    def outDegreeOf(v : V) : Option[Int] = ???\n\n    /** The number of adjacent vertices to input vertex\n      * @param v vertex\n      * @return [[None]] if `v` is not an actual vertex, the degree of `v` otherwise\n      */\n    def degreeOf(v : V) : Option[Int] = ???\n\n    /* VERTEX OPERATIONS */\n\n    /** Add vertex to graph\n      * @param v new vertex\n      * @return the graph with new vertex `v`\n      *         if `v` is an actual vertex of graph, return input graph\n      */\n    def + (v : V) : StrictGraph[V]\n\n    /** Remove vertex from graph\n      * @param v new vertex\n      * @return the graph without vertex `v`\n      *         if `v` is not an actual vertex of graph, return input graph\n      */\n    def - (v : V) : StrictGraph[V]\n\n    /* ARC OPERATIONS */\n\n    /** Add arc to graph (also add arc ends as new vertices if necessary)\n      * @param a new arc\n      * @return the graph with new arc `e`\n      *         if `e` is an actual arc of graph, return input graph\n      */\n    def +| (a : Arc[V]) : StrictGraph[V]\n\n    /** Remove arc from graph (does NOT remove ends)\n      * @param a new arc\n      * @return the graph without arc `e`\n      *         if `e` is not an actual arc of graph, return input graph\n      */\n    def -| (a : Arc[V]) : StrictGraph[V]\n\n    /** Remove all arcs from graph but keep same vertices\n      * @return graph with same vertices without any arc\n      */\n    def withoutArc : StrictGraph[V]\n\n    /** Add all possible arc with same vertices\n      * @return graph with same vertices and all possible arcs\n      */\n    def withAllArcs : StrictGraph[V]\n\n    /* SEARCH METHODS */\n\n    /** A topological order of the vertex set (if exists) */\n    lazy val topologicalOrder : Option[Seq[V]] = ???\n\n    /* VALUATED GRAPH METHODS */\n\n    /** Computes a shortest path between two vertices\n      * @param valuation valuation of graph\n      * @param start origin      of path\n      * @param end   destination of path\n      * @return [[None]] if there is no path from `start` to `end`, the shortest path and its valuation otherwise\n      */\n    def shortestPath(valuation : Map[Arc[V], Double])(start : V, end : V) : Option[(Seq[V], Double)] = ???\n\n    /* toString-LIKE METHODS */\n\n    /** @inheritdoc */\n    override lazy val toString : String = s\"({${vertices mkString \", \"}}, {${arcs mkString \", \"}})\"\n\n    /** Graph representation in DOT language */\n    lazy val toDOTString : String = {\n        \"strict graph {\\n\" +\n        \"    // Edges\\n\" +\n        (arcs foldLeft \"    \") { _ + _.toDOTString + \"\\n    \" } + \"\\n\" +\n        \"    // Vertices\\n\" +\n        vertices.mkString(\"    \", \"\\n    \", \"\\n\") +\n        \"  }\\n\"\n      }\n\n  }\n"}})[0m
