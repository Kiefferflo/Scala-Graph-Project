[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (/home/cytech/scala-graph-project/target/scala-2.13/zinc/inc_compile_2.13.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed Mar 9, 2022, 9:39:42 AM[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/graph.scala","languageId":"scala","version":1,"text":"object graph {\n  def main(args: Array[String]): Unit = {\n    //TODO\n  }\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/test/scala/directed/StrictGraphDefaultImplSpec.scala","languageId":"scala","version":1,"text":"package directed\n\nimport org.scalacheck.Gen\nimport org.scalacheck.Gen._\n\n/** The test class for [[StrictGraphDefaultImpl]] implementation */\nclass StrictGraphDefaultImplSpec extends StrictGraphSpec(StrictGraphDefaultImplSpec)\n\nobject StrictGraphDefaultImplSpec extends StrictGraphSpecCompanion[Int](\"StrictGraphDefaultImpl\") {\n    /** @inheritdoc */\n    val vertex : Gen[Int] = posNum[Int]\n\n    /** @inheritdoc */\n    def graphWithAtLeast(vertexMinCount: Int, arcMinCount: Int = 0): Gen[StrictGraphDefaultImpl[Int]] =\n      for(vertexAdditionalCount <- posNum[Int]; vertexCount <- Gen.const((vertexMinCount + vertexAdditionalCount) max 1);\n          vs <- Gen.containerOfN[Set, Int](vertexCount, vertex);\n          arcCount <- Gen.choose(arcMinCount, vertexCount * (vertexCount - 1) / 2);\n          as <- Gen.containerOfN[Set, Arc[Int]](arcCount, arcFrom(vs))) yield StrictGraphDefaultImpl(vs, as)\n  }\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/test/scala/directed/StrictGraphSpec.scala","languageId":"scala","version":1,"text":"package directed\n\nimport org.scalatest.flatspec.AnyFlatSpec\nimport org.scalatest.matchers.must.Matchers\nimport org.scalatestplus.scalacheck.ScalaCheckPropertyChecks.forAll\nimport org.scalacheck.Gen._\nimport org.scalacheck.Gen\n\n/** General template for test of [[StrictGraph]] implementations\n  * @param companion the companion object of test class (see [[StrictGraphSpecCompanion]] documentation)\n  */\nabstract class StrictGraphSpec[V](companion : StrictGraphSpecCompanion[V]) extends AnyFlatSpec with Matchers {\n    import companion._\n\n    /* QUERY METHODS */\n\n    behavior of s\"$name.successorsOf\"\n      it must \"yield None if input is not an actual vertex of graph\" in\n        forAll(graphAndNoActualVertex) { case (g, v) => (g successorsOf v) mustBe None }\n      it must \"yield a subset of vertex set if input is an actual vertex of graph\" in\n        forAll(graphAndActualVertex)   { case (g, v) => (g successorsOf v) map { _ subsetOf g.vertices } must equal (Some(true)) }\n      it must \"yield a set of adjacent vertices\" in\n        forAll(graphAndActualVertex)   { case (g, v) => (g successorsOf v).get forall { g.arcs contains Arc(v, _) }}\n\n    /* VERTEX OPERATIONS */\n\n    behavior of s\"$name.+\"\n      it must \"contain input vertex\" in\n        forAll(zip(graph, vertex))     { case (g, v) => (g + v).vertices must equal (g.vertices + v) }\n      it must \"return input graph if input vertex is already in graph\" in\n        forAll(graphAndActualVertex)   { case (g, v) =>  g + v           must equal   (g) }\n      it must \"have input vertex with degree 0 if not an actual vertex of graph\" in\n        forAll(graphAndNoActualVertex) { case (g, v) => (g + v) degreeOf v mustBe Some(0) }\n\n      behavior of s\"$name.-\"\n      it must \"NOT contain input vertex\" in\n        forAll(zip(graph, vertex))     { case (g, v) => (g - v).vertices must equal (g.vertices - v) }\n      it must \"return input graph if input vertex is not already in graph\" in\n        forAll(graphAndNoActualVertex) { case (g, v) =>  g - v      must equal (g) }\n      it must \"have input vertex removed from successors if an actual vertex of graph\" in\n        forAll(graphAndActualVertex)   { case (g, v) => (g successorsOf v).get forall { n => !((g - v).successorsOf(n).get contains v) } }\n      it must \"have degree updated for all successors if an actual vertex of graph\" in\n        forAll(graphAndActualVertex)   { case (g, v) => (g successorsOf v).get forall { n => (g - v).degreeOf(n) contains (g.degreeOf(n).get - 1) }}\n      it must \"revert back the + operator applied on an actual new vertex\" in\n        forAll(graphAndNoActualVertex) { case (g, v) => (g + v) - v must equal (g) }\n\n    /* ARC OPERATIONS */\n\n    behavior of s\"$name.+|\"\n      it must \"contain input arc\" in\n        forAll(zip(graph, arc))   { case (g, a) => (g +| a).arcs must equal (g.arcs + a) }\n      it must \"contain ends of input arc\" in\n        forAll(zip(graph, arc))   { case (g, a) => Set(a._1, a._2) subsetOf (g +| a).vertices mustBe true }\n      it must \"return input graph if input arc is already in graph\" in\n        forAll(graphAndActualArc) { case (g, a) =>  g +| a       must equal   (g) }\n\n    behavior of s\"$name.-|\"\n      it must \"NOT contain input arc\" in\n        forAll(zip(graph, arc))     { case (g, a) => (g -| a).arcs must equal (g.arcs - a) }\n      it must \"return input graph if input arc is not already in graph\" in\n        forAll(graphAndNoActualArc) { case (g, a) =>  g -| a       must equal (g) }\n      it must \"have ends removed from successors if an actual vertex of graph\" in\n        forAll(graphAndActualArc)   { case (g, a) => (g -| a).successorsOf(a._1) must not contain a._2 }\n      it must \"have degree updated for both ends if an actual vertex of graph\" in\n        forAll(graphAndActualArc)   { case (g, a) => (g degreeOf a._1 map { _ - 1}, g degreeOf a._2 map { _ - 1}) must equal ((g -| a) degreeOf a._1, (g -| a) degreeOf a._2) }\n\n    behavior of s\"$name.withoutArc\"\n      it must \"let vertex set unchanged\" in\n        forAll(graph) { g =>  g.withoutArc.vertices must equal (g.vertices) }\n      it must \"have empty arc set\" in\n        forAll(graph) { g =>  g.withoutArc.arcs mustBe empty }\n      it must \"have empty successors for any vertex\" in\n        forAll(graph) { g => (g.withoutArc.vertices forall { v => (g.withoutArc successorsOf v) == Some(Set.empty[V]) }) mustBe true }\n      it must \"have zero degree for any vertex\" in\n        forAll(graph) { g => (g.withoutArc.vertices forall { v => (g.withoutArc degreeOf v) == Some(0) }) mustBe true }\n  }\n\n/** General template for [[StrictGraphSpec]] companion objects\n  * @param name name of actual implementation\n  * @tparam V type of vertex used for test\n  */\nabstract class StrictGraphSpecCompanion[V](val name : String) {\n    /* BASIC GENERATORS */\n\n    /** The vertex generator */\n    val vertex : Gen[V]\n\n    /** The arc generator\n      * @param vertices set of vertices to pick from\n      *                 (if empty, generator [[vertex]] is used)\n      */\n    def arcFrom(vertices : Set[V]) : Gen[Arc[V]] = {\n        val vertexGenerator = if (vertices.isEmpty) vertex else Gen.oneOf(vertices)\n        for (v1 <- vertexGenerator ; v2 <- vertexGenerator if v1 != v2) yield Arc(v1, v2)\n      }\n\n    /** The arc generator */\n    lazy val arc : Gen[Arc[V]] = arcFrom(Set.empty[V])\n\n    /** The undirected simple graph generator\n      *\n      * If `g` is generated value, then it must be ensured that `g.vertices` is NOT empty.\n      */\n    val graph : Gen[StrictGraph[V]] = graphWithAtLeast(1)\n\n    /** The general directed simple graph generator\n      *\n      * If `g` is generated value, then it must be ensured that `g.vertices` have at least `vertexMinCount` elements\n      *                                                     and `g.arcs`    have at least   `arcMinCount` elements\n      * @param vertexMinCount minimal number of vertices to use\n      * @param arcMinCount   minimal number of arcs to use\n      */\n    def graphWithAtLeast(vertexMinCount : Int, arcMinCount : Int = 0) : Gen[StrictGraph[V]]\n\n    /** A positive-valued valuation generator\n      * @param arcs set of whose values must be defined\n      */\n    def positiveValuation(arcs : Set[Arc[V]]) : Gen[Map[Arc[V], Double]] =\n      for (values <- Gen.containerOfN[Seq, Double](arcs.size, posNum[Double])) yield (arcs.toSeq zip (values map {_ + 1})).to(Map)\n\n    /* ADVANCED GENERATORS */\n\n    /** A generator for a graph and a vertex of the graph\n      *\n      * If `(g, v)` is a generated value, then it must be ensured that `g.vertices` contains `v`.\n      */\n    lazy val graphAndActualVertex : Gen[(StrictGraph[V], V)] =\n      for (g <- graph ; v <- Gen.oneOf(g.vertices)) yield (g, v)\n\n    /** A generator for a graph and a vertex NOT in the graph\n      *\n      * If `(g, v)` is a generated value, then it must be ensured that `g.vertices` does not contain `v`.\n      */\n    lazy val graphAndNoActualVertex : Gen[(StrictGraph[V], V)] =\n      zip(graph, vertex) suchThat { case (g, v) => !(g.vertices contains v) }\n\n  /** A generator for a graph and an arc of the graph\n      *\n      * If `(g, a)` is a generated value, then it must be ensured that `g.arcs`    contains `a`.\n      */\n    lazy val graphAndActualArc : Gen[(StrictGraph[V], Arc[V])] =\n      for (g <- graphWithAtLeast(2, 1) ; a <- Gen.oneOf(g.arcs)) yield (g, a)\n\n    /** A generator for a graph and an arc NOT in the graph\n      *\n      * If `(g, a)` is a generated value, then it must be ensured that `g.arcs` does not contain `a`.\n      */\n    lazy val graphAndNoActualArc : Gen[(StrictGraph[V], Arc[V])] =\n      for (g <- graph ; a <- arcFrom(g.vertices) if !(g.arcs contains a)) yield (g, a)\n\n    /** A generator for a graph and a positive valuation */\n    lazy val graphAndValuation : Gen[(StrictGraph[V], Map[Arc[V], Double])] =\n      for (g <- graphWithAtLeast(2, 1) ; v <- positiveValuation(g.arcs)) yield (g, v)\n  }\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/test/scala/undirected/SimpleGraphSpec.scala","languageId":"scala","version":1,"text":"package undirected\n\nimport org.scalatest.flatspec.AnyFlatSpec\nimport org.scalatest.matchers.must.Matchers\nimport org.scalatestplus.scalacheck.ScalaCheckPropertyChecks.forAll\nimport org.scalacheck.Gen._\nimport org.scalacheck.Gen\n\n/** General template for test of [[SimpleGraph]] implementations\n  * @param companion the companion object of test class (see [[SimpleGraphSpecCompanion]] documentation)\n  */\nabstract class SimpleGraphSpec[V](companion : SimpleGraphSpecCompanion[V]) extends AnyFlatSpec with Matchers {\n    import companion._\n\n    /* QUERY METHODS */\n\n    behavior of s\"$name.neighborsOf\"\n      it must \"yield None if input is not an actual vertex of graph\" in\n        forAll(graphAndNoActualVertex) { case (g, v) => (g neighborsOf v) mustBe None }\n      it must \"yield a subset of vertex set if input is an actual vertex of graph\" in\n        forAll(graphAndActualVertex)   { case (g, v) => (g neighborsOf v) map { _ subsetOf g.vertices } must equal (Some(true)) }\n      it must \"yield a set of adjacent vertices\" in\n        forAll(graphAndActualVertex)   { case (g, v) => (g neighborsOf v).get forall { g.edges contains Edge(v, _) }}\n\n    /* VERTEX OPERATIONS */\n\n    behavior of s\"$name.+\"\n      it must \"contain input vertex\" in\n        forAll(zip(graph, vertex))     { case (g, v) => (g + v).vertices must equal (g.vertices + v) }\n      it must \"return input graph if input vertex is already in graph\" in\n        forAll(graphAndActualVertex)   { case (g, v) =>  g + v           must equal   (g) }\n      it must \"have input vertex with degree 0 if not an actual vertex of graph\" in\n        forAll(graphAndNoActualVertex) { case (g, v) => (g + v) degreeOf v mustBe Some(0) }\n\n    behavior of s\"$name.-\"\n      it must \"NOT contain input vertex\" in\n        forAll(zip(graph, vertex))     { case (g, v) => (g - v).vertices must equal (g.vertices - v) }\n      it must \"return input graph if input vertex is not already in graph\" in\n        forAll(graphAndNoActualVertex) { case (g, v) =>  g - v      must equal (g) }\n      it must \"have input vertex removed from neighbors if an actual vertex of graph\" in\n        forAll(graphAndActualVertex)   { case (g, v) => (g neighborsOf v).get forall { n => !((g - v).neighborsOf(n).get contains v) } }\n      it must \"have degree updated for all neighbors if an actual vertex of graph\" in\n        forAll(graphAndActualVertex)   { case (g, v) => (g neighborsOf v).get forall { n => (g - v).degreeOf(n) contains (g.degreeOf(n).get - 1) }}\n      it must \"revert back the + operator applied on an actual new vertex\" in\n        forAll(graphAndNoActualVertex) { case (g, v) => (g + v) - v must equal (g) }\n\n    /* EDGE OPERATIONS */\n\n    behavior of s\"$name.+|\"\n      it must \"contain input edge\" in\n        forAll(zip(graph, edge))   { case (g, e) => (g +| e).edges must equal (g.edges + e) }\n      it must \"contain ends of input edge\" in\n        forAll(zip(graph, edge))   { case (g, e) => Set(e._1, e._2) subsetOf (g +| e).vertices mustBe true }\n      it must \"return input graph if input edge is already in graph\" in\n        forAll(graphAndActualEdge) { case (g, e) =>  g +| e         must equal   (g) }\n\n    behavior of s\"$name.-|\"\n      it must \"NOT contain input edge\" in\n        forAll(zip(graph, edge))     { case (g, e) => (g -| e).edges must equal (g.edges - e) }\n      it must \"return input graph if input edge is not already in graph\" in\n        forAll(graphAndNoActualEdge) { case (g, e) =>  g -| e        must equal (g) }\n      it must \"have ends removed from neighbors if an actual vertex of graph\" in\n        forAll(graphAndActualEdge)   { case (g, e) => (g -| e).neighborsOf(e._1) must not contain e._2 }\n      it must \"have degree updated for both ends if an actual vertex of graph\" in\n        forAll(graphAndActualEdge)   { case (g, e) => (g degreeOf e._1 map { _ - 1}, g degreeOf e._2 map { _ - 1}) must equal ((g -| e) degreeOf e._1, (g -| e) degreeOf e._2) }\n\n    behavior of s\"$name.withoutEdge\"\n      it must \"let vertex set unchanged\" in\n        forAll(graph) { g =>  g.withoutEdge.vertices must equal (g.vertices) }\n      it must \"have empty edge set\" in\n        forAll(graph) { g =>  g.withoutEdge.edges mustBe empty }\n      it must \"have empty neighbors for any vertex\" in\n        forAll(graph) { g => (g.withoutEdge.vertices forall { v => (g.withoutEdge neighborsOf v) == Some(Set.empty[V]) }) mustBe true }\n      it must \"have zero degree for any vertex\" in\n        forAll(graph) { g => (g.withoutEdge.vertices forall { v => (g.withoutEdge degreeOf v) == Some(0) }) mustBe true }\n  }\n\n/** General template for [[SimpleGraphSpec]] companion objects\n  * @param name name of actual implementation\n  * @tparam V type of vertex used for test\n  */\nabstract class SimpleGraphSpecCompanion[V](val name : String) {\n    /* BASIC GENERATORS */\n\n    /** The vertex generator */\n    val vertex : Gen[V]\n\n    /** The edge generator\n      * @param vertices set of vertices to pick from\n      *                 (if empty, generator [[vertex]] is used)\n      */\n    def edgeFrom(vertices : Set[V]) : Gen[Edge[V]] = {\n        val vertexGenerator = if (vertices.isEmpty) vertex else Gen.oneOf(vertices)\n        for (v1 <- vertexGenerator ; v2 <- vertexGenerator if v1 != v2) yield Edge(v1, v2)\n      }\n\n    /** The edge generator */\n    lazy val edge : Gen[Edge[V]] = edgeFrom(Set.empty[V])\n\n    /** The undirected simple graph generator\n      *\n      * If `g` is generated value, then it must be ensured that `g.vertices` is NOT empty.\n      */\n    val graph : Gen[SimpleGraph[V]] = graphWithAtLeast(1)\n\n    /** The general directed simple graph generator\n      *\n      * If `g` is generated value, then it must be ensured that `g.vertices` have at least `vertexMinCount` elements\n      *                                                     and `g.edges`    have at least   `edgeMinCount` elements\n      * @param vertexMinCount minimal number of vertices to use\n      * @param edgeMinCount   minimal number of edges to use\n      */\n    def graphWithAtLeast(vertexMinCount : Int, edgeMinCount : Int = 0) : Gen[SimpleGraph[V]]\n\n    /** A positive-valued valuation generator\n      * @param edges set of whose values must be defined\n      */\n    def positiveValuation(edges : Set[Edge[V]]) : Gen[Map[Edge[V], Double]] =\n      for (values <- Gen.containerOfN[Seq, Double](edges.size, posNum[Double])) yield (edges.toSeq zip (values map {_ + 1})).to(Map)\n\n  /* ADVANCED GENERATORS */\n\n    /** A generator for a graph and a vertex of the graph\n      *\n      * If `(g, v)` is a generated value, then it must be ensured that `g.vertices` contains `v`.\n      */\n    lazy val graphAndActualVertex : Gen[(SimpleGraph[V], V)] =\n      for (g <- graph ; v <- Gen.oneOf(g.vertices)) yield (g, v)\n\n    /** A generator for a graph and a vertex NOT in the graph\n      *\n      * If `(g, v)` is a generated value, then it must be ensured that `g.vertices` does not contain `v`.\n      */\n    lazy val graphAndNoActualVertex : Gen[(SimpleGraph[V], V)] =\n      for (g <- graph ; v <- vertex if !(g.vertices contains v)) yield (g, v)\n\n    /** A generator for a graph and an edge of the graph\n      *\n      * If `(g, e)` is a generated value, then it must be ensured that `g.edges`    contains `e`.\n      */\n    lazy val graphAndActualEdge : Gen[(SimpleGraph[V], Edge[V])] =\n      for (g <- graphWithAtLeast(2, 1) ; e <- Gen.oneOf(g.edges)) yield (g, e)\n\n    /** A generator for a graph and an edge NOT in the graph\n      *\n      * If `(g, e)` is a generated value, then it must be ensured that `g.edges` does not contain `e`.\n      */\n    lazy val graphAndNoActualEdge : Gen[(SimpleGraph[V], Edge[V])] =\n      for (g <- graph ; e <- edgeFrom(g.vertices) if !(g.edges contains e)) yield (g, e)\n\n    /** A generator for a graph and a positive valuation */\n    lazy val graphAndValuation : Gen[(SimpleGraph[V], Map[Edge[V], Double])] =\n      for (g <- graphWithAtLeast(2, 1) ; v <- positiveValuation(g.edges)) yield (g, v)\n  }\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/test/scala/undirected/SimpleGraphDefaultImplSpec.scala","languageId":"scala","version":1,"text":"package undirected\n\nimport org.scalacheck.Gen\nimport org.scalacheck.Gen._\n\n/** The test class for [[SimpleGraphDefaultImpl]] implementation */\nclass SimpleGraphDefaultImplSpec extends SimpleGraphSpec(SimpleGraphDefaultImplSpec)\n\nobject SimpleGraphDefaultImplSpec extends SimpleGraphSpecCompanion[Int](\"SimpleGraphDefaultImpl\") {\n    /** @inheritdoc */\n    val vertex : Gen[Int] = posNum[Int]\n\n    /** @inheritdoc */\n    def graphWithAtLeast(vertexMinCount: Int, edgeMinCount: Int = 0): Gen[SimpleGraphDefaultImpl[Int]] =\n      for(vertexAdditionalCount <- posNum[Int] ; vertexCount <- Gen.const((vertexMinCount + vertexAdditionalCount) max 1) ;\n          vs <- Gen.containerOfN[Set, Int](vertexCount, vertex) ;\n          edgeCount <- Gen.choose(edgeMinCount, vertexCount * (vertexCount - 1) / 2) ;\n          es <- Gen.containerOfN[Set, Edge[Int]](edgeCount, edgeFrom(vs))) yield SimpleGraphDefaultImpl(vs, es)\n  }\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/directed/Arc.scala","languageId":"scala","version":1,"text":"package directed\n\n/** Arc of a directed graph as an ordered pair\n  * @param _1 origin      of edge\n  * @param _2 destination of edge\n  * @tparam V type of vertex\n  */\ncase class Arc[V](_1 : V, _2 : V) {\n    /** Arc representation in DOT language */\n    lazy val toDOTString : String = s\"${_1} -> ${_2}\"\n\n    /** @inheritdoc */\n    override lazy val toString : String = toDOTString\n  }\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/directed/StrictGraph.scala","languageId":"scala","version":1,"text":"package directed\n\nimport scala.annotation.tailrec\n\n/** Trait for a directed ''and strict'' graph, i.e. without loop nor parallel arcs */\ntrait StrictGraph[V] {\n    /* QUERY METHODS */\n\n    /** The set of all vertices of the graph */\n    val vertices : Set[V]\n\n    /** The set of all     arcs of the graph */\n    val arcs : Set[Arc[V]]\n\n    /** The set of all vertices with arcs incoming from input vertex\n      * @param v vertex\n      * @return [[None]] if `v` is not an actual vertex, the set of all successors of `v` otherwise\n      */\n    def successorsOf(v : V) : Option[Set[V]]\n\n    /** The number of incoming arcs to input vertex\n      * @param v vertex\n      * @return [[None]] if `v` is not an actual vertex, the inner degree of `v` otherwise\n      */\n    def inDegreeOf(v : V) : Option[Int] = ???\n\n    /** The number of outcoming arcs to input vertex\n      * @param v vertex\n      * @return [[None]] if `v` is not an actual vertex, the outer degree of `v` otherwise\n      */\n    def outDegreeOf(v : V) : Option[Int] = ???\n\n    /** The number of adjacent vertices to input vertex\n      * @param v vertex\n      * @return [[None]] if `v` is not an actual vertex, the degree of `v` otherwise\n      */\n    def degreeOf(v : V) : Option[Int] = ???\n\n    /* VERTEX OPERATIONS */\n\n    /** Add vertex to graph\n      * @param v new vertex\n      * @return the graph with new vertex `v`\n      *         if `v` is an actual vertex of graph, return input graph\n      */\n    def + (v : V) : StrictGraph[V]\n\n    /** Remove vertex from graph\n      * @param v new vertex\n      * @return the graph without vertex `v`\n      *         if `v` is not an actual vertex of graph, return input graph\n      */\n    def - (v : V) : StrictGraph[V]\n\n    /* ARC OPERATIONS */\n\n    /** Add arc to graph (also add arc ends as new vertices if necessary)\n      * @param a new arc\n      * @return the graph with new arc `e`\n      *         if `e` is an actual arc of graph, return input graph\n      */\n    def +| (a : Arc[V]) : StrictGraph[V]\n\n    /** Remove arc from graph (does NOT remove ends)\n      * @param a new arc\n      * @return the graph without arc `e`\n      *         if `e` is not an actual arc of graph, return input graph\n      */\n    def -| (a : Arc[V]) : StrictGraph[V]\n\n    /** Remove all arcs from graph but keep same vertices\n      * @return graph with same vertices without any arc\n      */\n    def withoutArc : StrictGraph[V]\n\n    /** Add all possible arc with same vertices\n      * @return graph with same vertices and all possible arcs\n      */\n    def withAllArcs : StrictGraph[V]\n\n    /* SEARCH METHODS */\n\n    /** A topological order of the vertex set (if exists) */\n    lazy val topologicalOrder : Option[Seq[V]] = ???\n\n    /* VALUATED GRAPH METHODS */\n\n    /** Computes a shortest path between two vertices\n      * @param valuation valuation of graph\n      * @param start origin      of path\n      * @param end   destination of path\n      * @return [[None]] if there is no path from `start` to `end`, the shortest path and its valuation otherwise\n      */\n    def shortestPath(valuation : Map[Arc[V], Double])(start : V, end : V) : Option[(Seq[V], Double)] = ???\n\n    /* toString-LIKE METHODS */\n\n    /** @inheritdoc */\n    override lazy val toString : String = s\"({${vertices mkString \", \"}}, {${arcs mkString \", \"}})\"\n\n    /** Graph representation in DOT language */\n    lazy val toDOTString : String = {\n        \"strict graph {\\n\" +\n        \"    // Edges\\n\" +\n        (arcs foldLeft \"    \") { _ + _.toDOTString + \"\\n    \" } + \"\\n\" +\n        \"    // Vertices\\n\" +\n        vertices.mkString(\"    \", \"\\n    \", \"\\n\") +\n        \"  }\\n\"\n      }\n\n  }\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/directed/StrictGraphDefaultImpl.scala","languageId":"scala","version":1,"text":"package directed\n\n/** Default implementation for [[StrictGraph]]\n  * @param vertices vertex set\n  * @param arcs arcs set\n  * @tparam V type for vertices\n  */\ncase class StrictGraphDefaultImpl[V](vertices : Set[V], arcs : Set[Arc[V]]) extends StrictGraph[V] {\n\n    /** @inheritdoc */\n    def successorsOf(v: V): Option[Set[V]] =\n      if (!(vertices contains v)) None else Some(vertices filter { arcs contains Arc(v, _) })\n\n    /** @inheritdoc */\n    def + (v: V): StrictGraphDefaultImpl[V] =\n      StrictGraphDefaultImpl(vertices + v, arcs)\n\n    /** @inheritdoc */\n    def - (v: V): StrictGraphDefaultImpl[V] =\n      StrictGraphDefaultImpl(vertices - v, arcs filterNot { e => Set(e._1, e._2) contains v })\n\n    /** @inheritdoc */\n    def +| (e: Arc[V]): StrictGraphDefaultImpl[V] =\n      StrictGraphDefaultImpl(vertices ++ Set(e._1, e._2), arcs + e)\n\n    /** @inheritdoc */\n    def -| (e: Arc[V]): StrictGraphDefaultImpl[V] =\n      StrictGraphDefaultImpl(vertices, arcs - e)\n\n    /** @inheritdoc */\n    def withoutArc: StrictGraphDefaultImpl[V] =\n      StrictGraphDefaultImpl(vertices, Set.empty[Arc[V]])\n\n    /** @inheritdoc */\n    def withAllArcs: StrictGraphDefaultImpl[V] =\n      StrictGraphDefaultImpl(vertices, for (v1 <- vertices ; v2 <- vertices) yield Arc(v1, v2))\n  }\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/directed/StrictGraphSuccessorsImpl.scala","languageId":"scala","version":1,"text":"package directed\n\n/** Implementation of [[StrictGraph]] using list of successors for each vertex\n  * @param successors associative map providing set of successors for each vertex\n  *                   Key must be defined for any vertex in graph : should an actual vertex have no neighbor, value is defined and is an empty set\n  * @tparam V type for vertices\n  */\ncase class StrictGraphSuccessorsImpl[V](successors : Map[V, Set[V]]) extends StrictGraph[V] {\n\n    /** @inheritdoc */\n    val vertices : Set[V] = ???\n\n    /** @inheritdoc */\n    val arcs : Set[Arc[V]] = ???\n\n    /** @inheritdoc */\n    def successorsOf(v: V) : Option[Set[V]] = ???\n\n    /** @inheritdoc */\n    def + (v : V) : StrictGraphSuccessorsImpl[V] = ???\n\n    /** @inheritdoc */\n    def - (v : V) : StrictGraphSuccessorsImpl[V] = ???\n\n    /** @inheritdoc */\n    def +| (e: Arc[V]) : StrictGraphSuccessorsImpl[V] = ???\n\n    /** @inheritdoc */\n    def -| (e: Arc[V]) : StrictGraphSuccessorsImpl[V] = ???\n\n    /** @inheritdoc */\n    def withoutArc : StrictGraphSuccessorsImpl[V] = ???\n\n    /** @inheritdoc */\n    def withAllArcs : StrictGraphSuccessorsImpl[V] = ???\n  }\n\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/undirected/SimpleGraph.scala","languageId":"scala","version":1,"text":"package undirected\n\nimport scala.annotation.tailrec\n\n/** Trait for an undirected and ''simple'' graph, that is without loop nor parallel edges\n  * @tparam V type for vertices\n  */\ntrait SimpleGraph[V] {\n    /* QUERY METHODS */\n\n    /** The set of all vertices of the graph */\n    val vertices : Set[V]\n\n    /** The set of all    edges of the graph */\n    val edges : Set[Edge[V]]\n\n    /** The set of all vertices adjacent to input vertex\n      * @param v vertex\n      * @return [[None]] if `v` is not an actual vertex, the set of all neighbors of `v` otherwise (may be empty)\n      */\n    def neighborsOf(v : V) : Option[Set[V]]\n\n    /** The number of adjacent vertices to input vertex\n      * @param v vertex\n      * @return [[None]] if `v` is not an actual vertex, the degree of `v` otherwise\n      */\n    def degreeOf(v : V) : Option[Int] = neighborsOf(v) map { _.size }\n\n    /** Checks if there exists a path between two vertices\n      * @param v1 one end of path to search\n      * @param v2 other end of path to search\n      * @return `true` if `v1` and `v2` are equal or if a path exists between `v1` and `v2`, `false` otherwise\n      */\n    def hasPath(v1 : V, v2 : V) : Boolean = ???\n\n    /** Checks if graph is connected */\n    lazy val isConnected : Boolean = ???\n\n    /** Checks if graph is acyclic */\n    lazy val isAcyclic : Boolean = ???\n\n    /** Checks if graph is a tree */\n    lazy val isTree : Boolean = isConnected && isAcyclic\n\n    /* VERTEX OPERATIONS */\n\n    /** Add vertex to graph\n      * @param v new vertex\n      * @return the graph with new vertex `v`\n      *         if `v` is an actual vertex of graph, return input graph\n      */\n    def + (v : V) : SimpleGraph[V]\n\n    /** Remove vertex from graph\n      * @param v new vertex\n      * @return the graph without vertex `v`\n      *         if `v` is not an actual vertex of graph, return input graph\n      */\n    def - (v : V) : SimpleGraph[V]\n\n    /* EDGE OPERATIONS */\n\n    /** Add edge to graph (also add edge ends as new vertices if necessary)\n      * @param e new edge\n      * @return the graph with new edge `e`\n      *         if `e` is an actual edge of graph, return input graph\n      */\n    def +| (e : Edge[V]) : SimpleGraph[V]\n\n    /** Remove edge from graph (does NOT remove ends)\n      * @param e new edge\n      * @return the graph without edge `e`\n      *         if `e` is not an actual edge of graph, return input graph\n      */\n    def -| (e : Edge[V]) : SimpleGraph[V]\n\n    /** Remove all edges from graph but keep same vertices\n      * @return graph with same vertices without any edge\n      */\n    def withoutEdge : SimpleGraph[V]\n\n    /** Add all possible edge with same vertices\n      * @return graph with same vertices and all possible edges\n      */\n    def withAllEdges : SimpleGraph[V]\n\n    /* VALUATED GRAPH METHODS */\n\n    /** Total value of the graph\n      * @param valuation valuation used\n      * @return total value of the graph, i.e. sum of values of all edges\n      */\n    def value(valuation : Map[Edge[V], Double]) : Double = (edges map { valuation(_) }).sum\n\n    /** Minimum spanning tree\n      * @param valuation valuation used\n      * @return a spanning tree whose value is minimal\n      */\n    def minimumSpanningTree(valuation : Map[Edge[V], Double]) : SimpleGraph[V] = ???\n\n    /* COLORING METHODS */\n\n    /** Sequence of vertices sorted by decreasing degree */\n    lazy val sortedVertices : Seq[V] = ???\n\n    /** Proper coloring using greedy algorithm (a.k.a WELSH-POWELL) */\n    lazy val greedyColoring : Map[V, Int] = ???\n\n    /** Proper coloring using DSATUR algorithm */\n    lazy val coloringDSATUR : Map[V, Int] = ???\n\n    /* toString-LIKE METHODS */\n\n    /** @inheritdoc */\n    override lazy val toString : String = s\"({${vertices mkString \", \"}}, {${edges mkString \", \"}})\"\n\n    /** Graph representation in DOT language */\n    lazy val toDOTString : String = {\n        \"strict graph {\\n\" +\n        \"    // Edges\\n\" +\n        (edges foldLeft \"    \") { _ + _.toDOTString + \"\\n    \" } + \"\\n\" +\n        \"    // Vertices\\n\" +\n        vertices.mkString(\"    \", \"\\n    \", \"\\n\") +\n        \"  }\\n\"\n      }\n\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/undirected/Edge.scala","languageId":"scala","version":1,"text":"package undirected\n\n/** Edge of an undirected graph as an unordered pair\n  *\n  * Source : [[https://gist.github.com/dmyersturnbull/2295d91ef503bb3eec6d]]\n  * @param _1 one end of edge\n  * @param _2 the other end of edge\n  * @tparam V type of vertex\n  */\ncase class Edge[V](_1 : V, _2 : V) {\n    /** Get the other end of the edge\n      * @param v one end\n      * @return [[None]] if `v` is not an actual end, the other end otherwise\n      */\n    def adjacentTo(v : V) : Option[V] =\n      if (v == _1) Some(_2) else if (v == _2) Some(_1) else None\n\n    /** Edge representation in DOT language */\n    lazy val toDOTString : String = s\"${_1} -- ${_2}\"\n\n    /** @inheritdoc */\n    override lazy val toString : String = toDOTString\n\n    /* [equals] is redefined so Edge(a, b) == Edge(b, a) */\n    /** @inheritdoc */\n    override def equals(o : Any) : Boolean = o match {\n        case that : Edge[V] => that._1 == _1 && that._2 == _2 || that._1 == _2 && that._2 == _1\n        case _              => false\n      }\n\n    /* [hashCode] is redefined so Edge(a, b).hashCode == Edge(b, a).hashCode */\n    /** @inheritdoc */\n    override def hashCode : Int = _1.hashCode * _2.hashCode\n  }\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/undirected/SimpleGraphDefaultImpl.scala","languageId":"scala","version":1,"text":"package undirected\n\n/** Default implementation for [[SimpleGraph]]\n  * @param vertices vertex set\n  * @param edges edges set\n  * @tparam V type for vertices\n  */\ncase class SimpleGraphDefaultImpl[V](vertices : Set[V], edges : Set[Edge[V]]) extends SimpleGraph[V] {\n    /** @inheritdoc */\n    def neighborsOf(v: V): Option[Set[V]] =\n      if (!(vertices contains v)) None else Some(vertices filter { edges contains Edge(v, _) })\n\n    /** @inheritdoc */\n    def + (v: V): SimpleGraphDefaultImpl[V] =\n      SimpleGraphDefaultImpl(vertices + v, edges)\n\n    /** @inheritdoc */\n    def - (v: V): SimpleGraphDefaultImpl[V] =\n      SimpleGraphDefaultImpl(vertices - v, edges filterNot { e => Set(e._1, e._2) contains v })\n\n    /** @inheritdoc */\n    def +| (e: Edge[V]): SimpleGraphDefaultImpl[V] =\n      SimpleGraphDefaultImpl(vertices ++ Set(e._1, e._2), edges + e)\n\n    /** @inheritdoc */\n    def -| (e: Edge[V]): SimpleGraphDefaultImpl[V] =\n      SimpleGraphDefaultImpl(vertices, edges - e)\n\n    /** @inheritdoc */\n    def withoutEdge: SimpleGraphDefaultImpl[V] =\n      SimpleGraphDefaultImpl(vertices, Set.empty[Edge[V]])\n\n    /** @inheritdoc */\n    def withAllEdges: SimpleGraphDefaultImpl[V] =\n      SimpleGraphDefaultImpl(vertices, for (v1 <- vertices ; v2 <- vertices) yield Edge(v1, v2))\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/undirected/SimpleGraphNeighborsImpl.scala","languageId":"scala","version":1,"text":"package undirected\n\n/** Implementation of [[SimpleGraph]] using list of neighbors for each vertex\n  * @param neighbors associative map providing set of neighbors for each vertex\n  *                  Key must be defined for any vertex in graph : should an actual vertex have no neighbor, value is defined and is an empty set\n  * @tparam V type for vertices\n  */\ncase class SimpleGraphNeighborsImpl[V](neighbors : Map[V, Set[V]]) extends SimpleGraph[V] {\n\n    /** @inheritdoc */\n    val vertices : Set[V] = ???\n\n    /** @inheritdoc */\n    val edges : Set[Edge[V]] = ???\n\n    /** @inheritdoc */\n    def neighborsOf(v: V) : Option[Set[V]] = ???\n\n    /** @inheritdoc */\n    def + (v : V) : SimpleGraphNeighborsImpl[V] = ???\n\n    /** @inheritdoc */\n    def - (v : V) : SimpleGraphNeighborsImpl[V] = ???\n\n    /** @inheritdoc */\n    def +| (e: Edge[V]) : SimpleGraphNeighborsImpl[V] = ???\n\n    /** @inheritdoc */\n    def -| (e: Edge[V]) : SimpleGraphNeighborsImpl[V] = ???\n\n    /** @inheritdoc */\n    def withoutEdge : SimpleGraphNeighborsImpl[V] = ???\n\n    /** @inheritdoc */\n    def withAllEdges : SimpleGraphNeighborsImpl[V] = ???\n}\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/undirected/SimpleGraphMatrixImpl.scala","languageId":"scala","version":1,"text":"package undirected\n\n/** Implementation of [[SimpleGraph]] using adjacency matrix\n  * @param vs sequence of vertices in the order they are used in adjacency matrix\n  * @param adjacency adjacency matrix\n  * @tparam V type for vertices\n  */\ncase class SimpleGraphMatrixImpl[V](vs : Seq[V], adjacency : IndexedSeq[IndexedSeq[Int]]) extends SimpleGraph[V] {\n\n    /** @inheritdoc */\n    lazy val vertices : Set[V] = ???\n\n    /** @inheritdoc */\n    lazy val edges : Set[Edge[V]] = ???\n\n    /** @inheritdoc */\n    def neighborsOf(v : V) : Option[Set[V]] = ???\n\n    /** @inheritdoc */\n    def + (v : V) : SimpleGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def - (v : V) : SimpleGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def +| (e : Edge[V]) : SimpleGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def -| (e : Edge[V]) : SimpleGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def withoutEdge : SimpleGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def withAllEdges : SimpleGraphMatrixImpl[V] = ???\n  }\n\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mForcing garbage collection...[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///home/cytech/scala-graph-project/src/main/scala/directed/StrictGraphMatrixImpl.scala","languageId":"scala","version":1,"text":"package directed\n\n/** Implementation of [[StrictGraph]] using adjacency matrix\n  * @param vs sequence of vertices in the order they are used in adjacency matrix\n  * @param adjacency adjacency matrix\n  * @tparam V type for vertices\n  */\ncase class StrictGraphMatrixImpl[V](vs : Seq[V], adjacency : IndexedSeq[IndexedSeq[Int]]) extends StrictGraph[V] {\n\n    /** @inheritdoc */\n    lazy val vertices : Set[V] = ???\n\n    /** @inheritdoc */\n    lazy val arcs : Set[Arc[V]] = ???\n\n    /** @inheritdoc */\n    def successorsOf(v : V) : Option[Set[V]] = ???\n\n    /** @inheritdoc */\n    def + (v : V) : StrictGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def - (v : V) : StrictGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def +| (e : Arc[V]) : StrictGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def -| (e : Arc[V]) : StrictGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def withoutArc : StrictGraphMatrixImpl[V] = ???\n\n    /** @inheritdoc */\n    def withAllArcs : StrictGraphMatrixImpl[V] = ???\n}\n\n"}})[0m
